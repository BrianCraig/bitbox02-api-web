// source: btc.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global = (function() {
  if (this) { return this; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  if (typeof self !== 'undefined') { return self; }
  return Function('return this')();
}.call(null));

var common_pb = require('./common_pb.js');
goog.object.extend(proto, common_pb);
var antiklepto_pb = require('./antiklepto_pb.js');
goog.object.extend(proto, antiklepto_pb);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCCoin', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCOutputType', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCPubRequest', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCPubRequest.OutputCase', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCPubRequest.XPubType', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.XPubType', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCRequest', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCRequest.RequestCase', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCResponse', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCResponse.ResponseCase', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCScriptConfig', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCScriptConfig.ConfigCase', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.ScriptType', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCScriptConfig.SimpleType', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCSignInitRequest', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCSignInputRequest', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCSignMessageRequest', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCSignMessageResponse', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCSignNextResponse', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCSignNextResponse.Type', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCSignOutputRequest', null, global);
goog.exportSymbol('proto.shiftcrypto.bitbox02.BTCSuccess', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.shiftcrypto.bitbox02.BTCScriptConfig.oneofGroups_);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCScriptConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCScriptConfig.displayName = 'proto.shiftcrypto.bitbox02.BTCScriptConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.repeatedFields_, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.displayName = 'proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCPubRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.shiftcrypto.bitbox02.BTCPubRequest.repeatedFields_, proto.shiftcrypto.bitbox02.BTCPubRequest.oneofGroups_);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCPubRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCPubRequest.displayName = 'proto.shiftcrypto.bitbox02.BTCPubRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.repeatedFields_, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.displayName = 'proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.shiftcrypto.bitbox02.BTCSignInitRequest.repeatedFields_, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCSignInitRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCSignInitRequest.displayName = 'proto.shiftcrypto.bitbox02.BTCSignInitRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCSignNextResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCSignNextResponse.displayName = 'proto.shiftcrypto.bitbox02.BTCSignNextResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.shiftcrypto.bitbox02.BTCSignInputRequest.repeatedFields_, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCSignInputRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCSignInputRequest.displayName = 'proto.shiftcrypto.bitbox02.BTCSignInputRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.shiftcrypto.bitbox02.BTCSignOutputRequest.repeatedFields_, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCSignOutputRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCSignOutputRequest.displayName = 'proto.shiftcrypto.bitbox02.BTCSignOutputRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.repeatedFields_, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.displayName = 'proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCSuccess = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCSuccess, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCSuccess.displayName = 'proto.shiftcrypto.bitbox02.BTCSuccess';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.displayName = 'proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.displayName = 'proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.displayName = 'proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.displayName = 'proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.displayName = 'proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.displayName = 'proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCSignMessageRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCSignMessageRequest.displayName = 'proto.shiftcrypto.bitbox02.BTCSignMessageRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCSignMessageResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCSignMessageResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCSignMessageResponse.displayName = 'proto.shiftcrypto.bitbox02.BTCSignMessageResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.shiftcrypto.bitbox02.BTCRequest.oneofGroups_);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCRequest.displayName = 'proto.shiftcrypto.bitbox02.BTCRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.shiftcrypto.bitbox02.BTCResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.shiftcrypto.bitbox02.BTCResponse.oneofGroups_);
};
goog.inherits(proto.shiftcrypto.bitbox02.BTCResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.shiftcrypto.bitbox02.BTCResponse.displayName = 'proto.shiftcrypto.bitbox02.BTCResponse';
}

/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.ConfigCase = {
  CONFIG_NOT_SET: 0,
  SIMPLE_TYPE: 1,
  MULTISIG: 2
};

/**
 * @return {proto.shiftcrypto.bitbox02.BTCScriptConfig.ConfigCase}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.prototype.getConfigCase = function() {
  return /** @type {proto.shiftcrypto.bitbox02.BTCScriptConfig.ConfigCase} */(jspb.Message.computeOneofCase(this, proto.shiftcrypto.bitbox02.BTCScriptConfig.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCScriptConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    simpleType: jspb.Message.getFieldWithDefault(msg, 1, 0),
    multisig: (f = msg.getMultisig()) && proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCScriptConfig;
  return proto.shiftcrypto.bitbox02.BTCScriptConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.shiftcrypto.bitbox02.BTCScriptConfig.SimpleType} */ (reader.readEnum());
      msg.setSimpleType(value);
      break;
    case 2:
      var value = new proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.deserializeBinaryFromReader);
      msg.setMultisig(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCScriptConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.shiftcrypto.bitbox02.BTCScriptConfig.SimpleType} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getMultisig();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.serializeBinaryToWriter
    );
  }
};


/**
 * @enum {number}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.SimpleType = {
  P2WPKH_P2SH: 0,
  P2WPKH: 1
};


/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.toObject = function(includeInstance, msg) {
  var f, obj = {
    threshold: jspb.Message.getFieldWithDefault(msg, 1, 0),
    xpubsList: jspb.Message.toObjectList(msg.getXpubsList(),
    common_pb.XPub.toObject, includeInstance),
    ourXpubIndex: jspb.Message.getFieldWithDefault(msg, 3, 0),
    scriptType: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig;
  return proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setThreshold(value);
      break;
    case 2:
      var value = new common_pb.XPub;
      reader.readMessage(value,common_pb.XPub.deserializeBinaryFromReader);
      msg.addXpubs(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOurXpubIndex(value);
      break;
    case 4:
      var value = /** @type {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.ScriptType} */ (reader.readEnum());
      msg.setScriptType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getThreshold();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getXpubsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      common_pb.XPub.serializeBinaryToWriter
    );
  }
  f = message.getOurXpubIndex();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getScriptType();
  if (f !== 0.0) {
    writer.writeEnum(
      4,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.ScriptType = {
  P2WSH: 0,
  P2WSH_P2SH: 1
};

/**
 * optional uint32 threshold = 1;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.prototype.getThreshold = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.prototype.setThreshold = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * repeated XPub xpubs = 2;
 * @return {!Array<!proto.shiftcrypto.bitbox02.XPub>}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.prototype.getXpubsList = function() {
  return /** @type{!Array<!proto.shiftcrypto.bitbox02.XPub>} */ (
    jspb.Message.getRepeatedWrapperField(this, common_pb.XPub, 2));
};


/**
 * @param {!Array<!proto.shiftcrypto.bitbox02.XPub>} value
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig} returns this
*/
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.prototype.setXpubsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.shiftcrypto.bitbox02.XPub=} opt_value
 * @param {number=} opt_index
 * @return {!proto.shiftcrypto.bitbox02.XPub}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.prototype.addXpubs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.shiftcrypto.bitbox02.XPub, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.prototype.clearXpubsList = function() {
  return this.setXpubsList([]);
};


/**
 * optional uint32 our_xpub_index = 3;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.prototype.getOurXpubIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.prototype.setOurXpubIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional ScriptType script_type = 4;
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.ScriptType}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.prototype.getScriptType = function() {
  return /** @type {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.ScriptType} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.ScriptType} value
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.prototype.setScriptType = function(value) {
  return jspb.Message.setProto3EnumField(this, 4, value);
};


/**
 * optional SimpleType simple_type = 1;
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig.SimpleType}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.prototype.getSimpleType = function() {
  return /** @type {!proto.shiftcrypto.bitbox02.BTCScriptConfig.SimpleType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfig.SimpleType} value
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.prototype.setSimpleType = function(value) {
  return jspb.Message.setOneofField(this, 1, proto.shiftcrypto.bitbox02.BTCScriptConfig.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.prototype.clearSimpleType = function() {
  return jspb.Message.setOneofField(this, 1, proto.shiftcrypto.bitbox02.BTCScriptConfig.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.prototype.hasSimpleType = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Multisig multisig = 2;
 * @return {?proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.prototype.getMultisig = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig, 2));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCScriptConfig.Multisig|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig} returns this
*/
proto.shiftcrypto.bitbox02.BTCScriptConfig.prototype.setMultisig = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.shiftcrypto.bitbox02.BTCScriptConfig.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfig} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.prototype.clearMultisig = function() {
  return this.setMultisig(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfig.prototype.hasMultisig = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.repeatedFields_ = [2];

/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.oneofGroups_ = [[3,4]];

/**
 * @enum {number}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.OutputCase = {
  OUTPUT_NOT_SET: 0,
  XPUB_TYPE: 3,
  SCRIPT_CONFIG: 4
};

/**
 * @return {proto.shiftcrypto.bitbox02.BTCPubRequest.OutputCase}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.getOutputCase = function() {
  return /** @type {proto.shiftcrypto.bitbox02.BTCPubRequest.OutputCase} */(jspb.Message.computeOneofCase(this, proto.shiftcrypto.bitbox02.BTCPubRequest.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCPubRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCPubRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    coin: jspb.Message.getFieldWithDefault(msg, 1, 0),
    keypathList: (f = jspb.Message.getRepeatedField(msg, 2)) == null ? undefined : f,
    xpubType: jspb.Message.getFieldWithDefault(msg, 3, 0),
    scriptConfig: (f = msg.getScriptConfig()) && proto.shiftcrypto.bitbox02.BTCScriptConfig.toObject(includeInstance, f),
    display: jspb.Message.getBooleanFieldWithDefault(msg, 5, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCPubRequest}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCPubRequest;
  return proto.shiftcrypto.bitbox02.BTCPubRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCPubRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCPubRequest}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.shiftcrypto.bitbox02.BTCCoin} */ (reader.readEnum());
      msg.setCoin(value);
      break;
    case 2:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedUint32() : [reader.readUint32()]);
      for (var i = 0; i < values.length; i++) {
        msg.addKeypath(values[i]);
      }
      break;
    case 3:
      var value = /** @type {!proto.shiftcrypto.bitbox02.BTCPubRequest.XPubType} */ (reader.readEnum());
      msg.setXpubType(value);
      break;
    case 4:
      var value = new proto.shiftcrypto.bitbox02.BTCScriptConfig;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCScriptConfig.deserializeBinaryFromReader);
      msg.setScriptConfig(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDisplay(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCPubRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCPubRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCoin();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getKeypathList();
  if (f.length > 0) {
    writer.writePackedUint32(
      2,
      f
    );
  }
  f = /** @type {!proto.shiftcrypto.bitbox02.BTCPubRequest.XPubType} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeEnum(
      3,
      f
    );
  }
  f = message.getScriptConfig();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.shiftcrypto.bitbox02.BTCScriptConfig.serializeBinaryToWriter
    );
  }
  f = message.getDisplay();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.XPubType = {
  TPUB: 0,
  XPUB: 1,
  YPUB: 2,
  ZPUB: 3,
  VPUB: 4,
  UPUB: 5,
  CAPITAL_VPUB: 6,
  CAPITAL_ZPUB: 7,
  CAPITAL_UPUB: 8,
  CAPITAL_YPUB: 9
};

/**
 * optional BTCCoin coin = 1;
 * @return {!proto.shiftcrypto.bitbox02.BTCCoin}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.getCoin = function() {
  return /** @type {!proto.shiftcrypto.bitbox02.BTCCoin} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.shiftcrypto.bitbox02.BTCCoin} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPubRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.setCoin = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * repeated uint32 keypath = 2;
 * @return {!Array<number>}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.getKeypathList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPubRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.setKeypathList = function(value) {
  return jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.shiftcrypto.bitbox02.BTCPubRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.addKeypath = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.shiftcrypto.bitbox02.BTCPubRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.clearKeypathList = function() {
  return this.setKeypathList([]);
};


/**
 * optional XPubType xpub_type = 3;
 * @return {!proto.shiftcrypto.bitbox02.BTCPubRequest.XPubType}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.getXpubType = function() {
  return /** @type {!proto.shiftcrypto.bitbox02.BTCPubRequest.XPubType} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {!proto.shiftcrypto.bitbox02.BTCPubRequest.XPubType} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPubRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.setXpubType = function(value) {
  return jspb.Message.setOneofField(this, 3, proto.shiftcrypto.bitbox02.BTCPubRequest.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCPubRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.clearXpubType = function() {
  return jspb.Message.setOneofField(this, 3, proto.shiftcrypto.bitbox02.BTCPubRequest.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.hasXpubType = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional BTCScriptConfig script_config = 4;
 * @return {?proto.shiftcrypto.bitbox02.BTCScriptConfig}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.getScriptConfig = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCScriptConfig} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCScriptConfig, 4));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCScriptConfig|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPubRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.setScriptConfig = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.shiftcrypto.bitbox02.BTCPubRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCPubRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.clearScriptConfig = function() {
  return this.setScriptConfig(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.hasScriptConfig = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bool display = 5;
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.getDisplay = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 5, false));
};


/**
 * @param {boolean} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPubRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPubRequest.prototype.setDisplay = function(value) {
  return jspb.Message.setProto3BooleanField(this, 5, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.repeatedFields_ = [3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.toObject = function(includeInstance, msg) {
  var f, obj = {
    scriptConfig: (f = msg.getScriptConfig()) && proto.shiftcrypto.bitbox02.BTCScriptConfig.toObject(includeInstance, f),
    keypathList: (f = jspb.Message.getRepeatedField(msg, 3)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath;
  return proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 2:
      var value = new proto.shiftcrypto.bitbox02.BTCScriptConfig;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCScriptConfig.deserializeBinaryFromReader);
      msg.setScriptConfig(value);
      break;
    case 3:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedUint32() : [reader.readUint32()]);
      for (var i = 0; i < values.length; i++) {
        msg.addKeypath(values[i]);
      }
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getScriptConfig();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.shiftcrypto.bitbox02.BTCScriptConfig.serializeBinaryToWriter
    );
  }
  f = message.getKeypathList();
  if (f.length > 0) {
    writer.writePackedUint32(
      3,
      f
    );
  }
};


/**
 * optional BTCScriptConfig script_config = 2;
 * @return {?proto.shiftcrypto.bitbox02.BTCScriptConfig}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.prototype.getScriptConfig = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCScriptConfig} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCScriptConfig, 2));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCScriptConfig|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath} returns this
*/
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.prototype.setScriptConfig = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.prototype.clearScriptConfig = function() {
  return this.setScriptConfig(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.prototype.hasScriptConfig = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * repeated uint32 keypath = 3;
 * @return {!Array<number>}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.prototype.getKeypathList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 3));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.prototype.setKeypathList = function(value) {
  return jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.prototype.addKeypath = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.prototype.clearKeypathList = function() {
  return this.setKeypathList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCSignInitRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCSignInitRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    coin: jspb.Message.getFieldWithDefault(msg, 1, 0),
    scriptConfigsList: jspb.Message.toObjectList(msg.getScriptConfigsList(),
    proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.toObject, includeInstance),
    version: jspb.Message.getFieldWithDefault(msg, 4, 0),
    numInputs: jspb.Message.getFieldWithDefault(msg, 5, 0),
    numOutputs: jspb.Message.getFieldWithDefault(msg, 6, 0),
    locktime: jspb.Message.getFieldWithDefault(msg, 7, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInitRequest}
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCSignInitRequest;
  return proto.shiftcrypto.bitbox02.BTCSignInitRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCSignInitRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInitRequest}
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.shiftcrypto.bitbox02.BTCCoin} */ (reader.readEnum());
      msg.setCoin(value);
      break;
    case 2:
      var value = new proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.deserializeBinaryFromReader);
      msg.addScriptConfigs(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVersion(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumInputs(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumOutputs(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLocktime(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCSignInitRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCSignInitRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCoin();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getScriptConfigsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.serializeBinaryToWriter
    );
  }
  f = message.getVersion();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getNumInputs();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = message.getNumOutputs();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = message.getLocktime();
  if (f !== 0) {
    writer.writeUint32(
      7,
      f
    );
  }
};


/**
 * optional BTCCoin coin = 1;
 * @return {!proto.shiftcrypto.bitbox02.BTCCoin}
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.getCoin = function() {
  return /** @type {!proto.shiftcrypto.bitbox02.BTCCoin} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.shiftcrypto.bitbox02.BTCCoin} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInitRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.setCoin = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * repeated BTCScriptConfigWithKeypath script_configs = 2;
 * @return {!Array<!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath>}
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.getScriptConfigsList = function() {
  return /** @type{!Array<!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath, 2));
};


/**
 * @param {!Array<!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath>} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInitRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.setScriptConfigsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath=} opt_value
 * @param {number=} opt_index
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath}
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.addScriptConfigs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInitRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.clearScriptConfigsList = function() {
  return this.setScriptConfigsList([]);
};


/**
 * optional uint32 version = 4;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInitRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.setVersion = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional uint32 num_inputs = 5;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.getNumInputs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInitRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.setNumInputs = function(value) {
  return jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional uint32 num_outputs = 6;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.getNumOutputs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInitRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.setNumOutputs = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * optional uint32 locktime = 7;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.getLocktime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInitRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInitRequest.prototype.setLocktime = function(value) {
  return jspb.Message.setProto3IntField(this, 7, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCSignNextResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCSignNextResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getFieldWithDefault(msg, 1, 0),
    index: jspb.Message.getFieldWithDefault(msg, 2, 0),
    hasSignature: jspb.Message.getBooleanFieldWithDefault(msg, 3, false),
    signature: msg.getSignature_asB64(),
    prevIndex: jspb.Message.getFieldWithDefault(msg, 5, 0),
    antiKleptoSignerCommitment: (f = msg.getAntiKleptoSignerCommitment()) && antiklepto_pb.AntiKleptoSignerCommitment.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignNextResponse}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCSignNextResponse;
  return proto.shiftcrypto.bitbox02.BTCSignNextResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCSignNextResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignNextResponse}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.shiftcrypto.bitbox02.BTCSignNextResponse.Type} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndex(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setHasSignature(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPrevIndex(value);
      break;
    case 6:
      var value = new antiklepto_pb.AntiKleptoSignerCommitment;
      reader.readMessage(value,antiklepto_pb.AntiKleptoSignerCommitment.deserializeBinaryFromReader);
      msg.setAntiKleptoSignerCommitment(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCSignNextResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCSignNextResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getHasSignature();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getPrevIndex();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = message.getAntiKleptoSignerCommitment();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      antiklepto_pb.AntiKleptoSignerCommitment.serializeBinaryToWriter
    );
  }
};


/**
 * @enum {number}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.Type = {
  INPUT: 0,
  OUTPUT: 1,
  DONE: 2,
  PREVTX_INIT: 3,
  PREVTX_INPUT: 4,
  PREVTX_OUTPUT: 5,
  HOST_NONCE: 6
};

/**
 * optional Type type = 1;
 * @return {!proto.shiftcrypto.bitbox02.BTCSignNextResponse.Type}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.getType = function() {
  return /** @type {!proto.shiftcrypto.bitbox02.BTCSignNextResponse.Type} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.shiftcrypto.bitbox02.BTCSignNextResponse.Type} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignNextResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.setType = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional uint32 index = 2;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignNextResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.setIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bool has_signature = 3;
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.getHasSignature = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 3, false));
};


/**
 * @param {boolean} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignNextResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.setHasSignature = function(value) {
  return jspb.Message.setProto3BooleanField(this, 3, value);
};


/**
 * optional bytes signature = 4;
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.getSignature = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes signature = 4;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignNextResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.setSignature = function(value) {
  return jspb.Message.setProto3BytesField(this, 4, value);
};


/**
 * optional uint32 prev_index = 5;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.getPrevIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignNextResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.setPrevIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional AntiKleptoSignerCommitment anti_klepto_signer_commitment = 6;
 * @return {?proto.shiftcrypto.bitbox02.AntiKleptoSignerCommitment}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.getAntiKleptoSignerCommitment = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.AntiKleptoSignerCommitment} */ (
    jspb.Message.getWrapperField(this, antiklepto_pb.AntiKleptoSignerCommitment, 6));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.AntiKleptoSignerCommitment|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignNextResponse} returns this
*/
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.setAntiKleptoSignerCommitment = function(value) {
  return jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignNextResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.clearAntiKleptoSignerCommitment = function() {
  return this.setAntiKleptoSignerCommitment(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCSignNextResponse.prototype.hasAntiKleptoSignerCommitment = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.repeatedFields_ = [6];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCSignInputRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    prevouthash: msg.getPrevouthash_asB64(),
    prevoutindex: jspb.Message.getFieldWithDefault(msg, 2, 0),
    prevoutvalue: jspb.Message.getFieldWithDefault(msg, 3, 0),
    sequence: jspb.Message.getFieldWithDefault(msg, 4, 0),
    keypathList: (f = jspb.Message.getRepeatedField(msg, 6)) == null ? undefined : f,
    scriptConfigIndex: jspb.Message.getFieldWithDefault(msg, 7, 0),
    hostNonceCommitment: (f = msg.getHostNonceCommitment()) && antiklepto_pb.AntiKleptoHostNonceCommitment.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInputRequest}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCSignInputRequest;
  return proto.shiftcrypto.bitbox02.BTCSignInputRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInputRequest}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrevouthash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPrevoutindex(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setPrevoutvalue(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSequence(value);
      break;
    case 6:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedUint32() : [reader.readUint32()]);
      for (var i = 0; i < values.length; i++) {
        msg.addKeypath(values[i]);
      }
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setScriptConfigIndex(value);
      break;
    case 8:
      var value = new antiklepto_pb.AntiKleptoHostNonceCommitment;
      reader.readMessage(value,antiklepto_pb.AntiKleptoHostNonceCommitment.deserializeBinaryFromReader);
      msg.setHostNonceCommitment(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCSignInputRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPrevouthash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getPrevoutindex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getPrevoutvalue();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = message.getSequence();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getKeypathList();
  if (f.length > 0) {
    writer.writePackedUint32(
      6,
      f
    );
  }
  f = message.getScriptConfigIndex();
  if (f !== 0) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = message.getHostNonceCommitment();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      antiklepto_pb.AntiKleptoHostNonceCommitment.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes prevOutHash = 1;
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.getPrevouthash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes prevOutHash = 1;
 * This is a type-conversion wrapper around `getPrevouthash()`
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.getPrevouthash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrevouthash()));
};


/**
 * optional bytes prevOutHash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrevouthash()`
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.getPrevouthash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrevouthash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.setPrevouthash = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional uint32 prevOutIndex = 2;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.getPrevoutindex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.setPrevoutindex = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional uint64 prevOutValue = 3;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.getPrevoutvalue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.setPrevoutvalue = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional uint32 sequence = 4;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.getSequence = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.setSequence = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * repeated uint32 keypath = 6;
 * @return {!Array<number>}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.getKeypathList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 6));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.setKeypathList = function(value) {
  return jspb.Message.setField(this, 6, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.addKeypath = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 6, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.clearKeypathList = function() {
  return this.setKeypathList([]);
};


/**
 * optional uint32 script_config_index = 7;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.getScriptConfigIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.setScriptConfigIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 7, value);
};


/**
 * optional AntiKleptoHostNonceCommitment host_nonce_commitment = 8;
 * @return {?proto.shiftcrypto.bitbox02.AntiKleptoHostNonceCommitment}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.getHostNonceCommitment = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.AntiKleptoHostNonceCommitment} */ (
    jspb.Message.getWrapperField(this, antiklepto_pb.AntiKleptoHostNonceCommitment, 8));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.AntiKleptoHostNonceCommitment|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.setHostNonceCommitment = function(value) {
  return jspb.Message.setWrapperField(this, 8, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.clearHostNonceCommitment = function() {
  return this.setHostNonceCommitment(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCSignInputRequest.prototype.hasHostNonceCommitment = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCSignOutputRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    ours: jspb.Message.getBooleanFieldWithDefault(msg, 1, false),
    type: jspb.Message.getFieldWithDefault(msg, 2, 0),
    value: jspb.Message.getFieldWithDefault(msg, 3, 0),
    hash: msg.getHash_asB64(),
    keypathList: (f = jspb.Message.getRepeatedField(msg, 5)) == null ? undefined : f,
    scriptConfigIndex: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest}
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCSignOutputRequest;
  return proto.shiftcrypto.bitbox02.BTCSignOutputRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest}
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setOurs(value);
      break;
    case 2:
      var value = /** @type {!proto.shiftcrypto.bitbox02.BTCOutputType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setValue(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    case 5:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedUint32() : [reader.readUint32()]);
      for (var i = 0; i < values.length; i++) {
        msg.addKeypath(values[i]);
      }
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setScriptConfigIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCSignOutputRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getOurs();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getValue();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = message.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getKeypathList();
  if (f.length > 0) {
    writer.writePackedUint32(
      5,
      f
    );
  }
  f = message.getScriptConfigIndex();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
};


/**
 * optional bool ours = 1;
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.getOurs = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 1, false));
};


/**
 * @param {boolean} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.setOurs = function(value) {
  return jspb.Message.setProto3BooleanField(this, 1, value);
};


/**
 * optional BTCOutputType type = 2;
 * @return {!proto.shiftcrypto.bitbox02.BTCOutputType}
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.getType = function() {
  return /** @type {!proto.shiftcrypto.bitbox02.BTCOutputType} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.shiftcrypto.bitbox02.BTCOutputType} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.setType = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional uint64 value = 3;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.setValue = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional bytes hash = 4;
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.getHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes hash = 4;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.setHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 4, value);
};


/**
 * repeated uint32 keypath = 5;
 * @return {!Array<number>}
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.getKeypathList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 5));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.setKeypathList = function(value) {
  return jspb.Message.setField(this, 5, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.addKeypath = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 5, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.clearKeypathList = function() {
  return this.setKeypathList([]);
};


/**
 * optional uint32 script_config_index = 6;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.getScriptConfigIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignOutputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignOutputRequest.prototype.setScriptConfigIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.repeatedFields_ = [3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.toObject = function(includeInstance, msg) {
  var f, obj = {
    coin: jspb.Message.getFieldWithDefault(msg, 1, 0),
    scriptConfig: (f = msg.getScriptConfig()) && proto.shiftcrypto.bitbox02.BTCScriptConfig.toObject(includeInstance, f),
    keypathList: (f = jspb.Message.getRepeatedField(msg, 3)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration;
  return proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.shiftcrypto.bitbox02.BTCCoin} */ (reader.readEnum());
      msg.setCoin(value);
      break;
    case 2:
      var value = new proto.shiftcrypto.bitbox02.BTCScriptConfig;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCScriptConfig.deserializeBinaryFromReader);
      msg.setScriptConfig(value);
      break;
    case 3:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedUint32() : [reader.readUint32()]);
      for (var i = 0; i < values.length; i++) {
        msg.addKeypath(values[i]);
      }
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCoin();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getScriptConfig();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.shiftcrypto.bitbox02.BTCScriptConfig.serializeBinaryToWriter
    );
  }
  f = message.getKeypathList();
  if (f.length > 0) {
    writer.writePackedUint32(
      3,
      f
    );
  }
};


/**
 * optional BTCCoin coin = 1;
 * @return {!proto.shiftcrypto.bitbox02.BTCCoin}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.prototype.getCoin = function() {
  return /** @type {!proto.shiftcrypto.bitbox02.BTCCoin} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.shiftcrypto.bitbox02.BTCCoin} value
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.prototype.setCoin = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional BTCScriptConfig script_config = 2;
 * @return {?proto.shiftcrypto.bitbox02.BTCScriptConfig}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.prototype.getScriptConfig = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCScriptConfig} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCScriptConfig, 2));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCScriptConfig|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration} returns this
*/
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.prototype.setScriptConfig = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.prototype.clearScriptConfig = function() {
  return this.setScriptConfig(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.prototype.hasScriptConfig = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * repeated uint32 keypath = 3;
 * @return {!Array<number>}
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.prototype.getKeypathList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 3));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.prototype.setKeypathList = function(value) {
  return jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.prototype.addKeypath = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration} returns this
 */
proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.prototype.clearKeypathList = function() {
  return this.setKeypathList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCSuccess.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCSuccess.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCSuccess} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSuccess.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCSuccess}
 */
proto.shiftcrypto.bitbox02.BTCSuccess.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCSuccess;
  return proto.shiftcrypto.bitbox02.BTCSuccess.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCSuccess} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCSuccess}
 */
proto.shiftcrypto.bitbox02.BTCSuccess.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCSuccess.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCSuccess.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCSuccess} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSuccess.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    registration: (f = msg.getRegistration()) && proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest}
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest;
  return proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest}
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.deserializeBinaryFromReader);
      msg.setRegistration(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRegistration();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.serializeBinaryToWriter
    );
  }
};


/**
 * optional BTCScriptConfigRegistration registration = 1;
 * @return {?proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration}
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.prototype.getRegistration = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration, 1));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.prototype.setRegistration = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.prototype.clearRegistration = function() {
  return this.setRegistration(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.prototype.hasRegistration = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    isRegistered: jspb.Message.getBooleanFieldWithDefault(msg, 1, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse}
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse;
  return proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse}
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsRegistered(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIsRegistered();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * optional bool is_registered = 1;
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.prototype.getIsRegistered = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 1, false));
};


/**
 * @param {boolean} value
 * @return {!proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.prototype.setIsRegistered = function(value) {
  return jspb.Message.setProto3BooleanField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    registration: (f = msg.getRegistration()) && proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.toObject(includeInstance, f),
    name: jspb.Message.getFieldWithDefault(msg, 2, ""),
    xpubType: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest}
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest;
  return proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest}
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.deserializeBinaryFromReader);
      msg.setRegistration(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 3:
      var value = /** @type {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.XPubType} */ (reader.readEnum());
      msg.setXpubType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRegistration();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration.serializeBinaryToWriter
    );
  }
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getXpubType();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.XPubType = {
  AUTO_ELECTRUM: 0,
  AUTO_XPUB_TPUB: 1
};

/**
 * optional BTCScriptConfigRegistration registration = 1;
 * @return {?proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration}
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.prototype.getRegistration = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration, 1));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCScriptConfigRegistration|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.prototype.setRegistration = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.prototype.clearRegistration = function() {
  return this.setRegistration(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.prototype.hasRegistration = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string name = 2;
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional XPubType xpub_type = 3;
 * @return {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.XPubType}
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.prototype.getXpubType = function() {
  return /** @type {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.XPubType} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.XPubType} value
 * @return {!proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.prototype.setXpubType = function(value) {
  return jspb.Message.setProto3EnumField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    version: jspb.Message.getFieldWithDefault(msg, 1, 0),
    numInputs: jspb.Message.getFieldWithDefault(msg, 2, 0),
    numOutputs: jspb.Message.getFieldWithDefault(msg, 3, 0),
    locktime: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest;
  return proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVersion(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumInputs(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumOutputs(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLocktime(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVersion();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getNumInputs();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getNumOutputs();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getLocktime();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
};


/**
 * optional uint32 version = 1;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.prototype.setVersion = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint32 num_inputs = 2;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.prototype.getNumInputs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.prototype.setNumInputs = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional uint32 num_outputs = 3;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.prototype.getNumOutputs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.prototype.setNumOutputs = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional uint32 locktime = 4;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.prototype.getLocktime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.prototype.setLocktime = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    prevOutHash: msg.getPrevOutHash_asB64(),
    prevOutIndex: jspb.Message.getFieldWithDefault(msg, 2, 0),
    signatureScript: msg.getSignatureScript_asB64(),
    sequence: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest;
  return proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrevOutHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPrevOutIndex(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignatureScript(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSequence(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPrevOutHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getPrevOutIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getSignatureScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getSequence();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
};


/**
 * optional bytes prev_out_hash = 1;
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.getPrevOutHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes prev_out_hash = 1;
 * This is a type-conversion wrapper around `getPrevOutHash()`
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.getPrevOutHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrevOutHash()));
};


/**
 * optional bytes prev_out_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrevOutHash()`
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.getPrevOutHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrevOutHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.setPrevOutHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional uint32 prev_out_index = 2;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.getPrevOutIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.setPrevOutIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bytes signature_script = 3;
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.getSignatureScript = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes signature_script = 3;
 * This is a type-conversion wrapper around `getSignatureScript()`
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.getSignatureScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignatureScript()));
};


/**
 * optional bytes signature_script = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignatureScript()`
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.getSignatureScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignatureScript()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.setSignatureScript = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional uint32 sequence = 4;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.getSequence = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.prototype.setSequence = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, 0),
    pubkeyScript: msg.getPubkeyScript_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest;
  return proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setValue(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPubkeyScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getPubkeyScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional uint64 value = 1;
 * @return {number}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.prototype.setValue = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional bytes pubkey_script = 2;
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.prototype.getPubkeyScript = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes pubkey_script = 2;
 * This is a type-conversion wrapper around `getPubkeyScript()`
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.prototype.getPubkeyScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPubkeyScript()));
};


/**
 * optional bytes pubkey_script = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPubkeyScript()`
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.prototype.getPubkeyScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPubkeyScript()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.prototype.setPubkeyScript = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCSignMessageRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCSignMessageRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    coin: jspb.Message.getFieldWithDefault(msg, 1, 0),
    scriptConfig: (f = msg.getScriptConfig()) && proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.toObject(includeInstance, f),
    msg: msg.getMsg_asB64(),
    hostNonceCommitment: (f = msg.getHostNonceCommitment()) && antiklepto_pb.AntiKleptoHostNonceCommitment.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignMessageRequest}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCSignMessageRequest;
  return proto.shiftcrypto.bitbox02.BTCSignMessageRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCSignMessageRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignMessageRequest}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.shiftcrypto.bitbox02.BTCCoin} */ (reader.readEnum());
      msg.setCoin(value);
      break;
    case 2:
      var value = new proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.deserializeBinaryFromReader);
      msg.setScriptConfig(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMsg(value);
      break;
    case 4:
      var value = new antiklepto_pb.AntiKleptoHostNonceCommitment;
      reader.readMessage(value,antiklepto_pb.AntiKleptoHostNonceCommitment.deserializeBinaryFromReader);
      msg.setHostNonceCommitment(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCSignMessageRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCSignMessageRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCoin();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getScriptConfig();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.serializeBinaryToWriter
    );
  }
  f = message.getMsg_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getHostNonceCommitment();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      antiklepto_pb.AntiKleptoHostNonceCommitment.serializeBinaryToWriter
    );
  }
};


/**
 * optional BTCCoin coin = 1;
 * @return {!proto.shiftcrypto.bitbox02.BTCCoin}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.getCoin = function() {
  return /** @type {!proto.shiftcrypto.bitbox02.BTCCoin} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.shiftcrypto.bitbox02.BTCCoin} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignMessageRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.setCoin = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional BTCScriptConfigWithKeypath script_config = 2;
 * @return {?proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.getScriptConfig = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath, 2));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCScriptConfigWithKeypath|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignMessageRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.setScriptConfig = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignMessageRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.clearScriptConfig = function() {
  return this.setScriptConfig(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.hasScriptConfig = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes msg = 3;
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.getMsg = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes msg = 3;
 * This is a type-conversion wrapper around `getMsg()`
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.getMsg_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMsg()));
};


/**
 * optional bytes msg = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMsg()`
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.getMsg_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMsg()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignMessageRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.setMsg = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional AntiKleptoHostNonceCommitment host_nonce_commitment = 4;
 * @return {?proto.shiftcrypto.bitbox02.AntiKleptoHostNonceCommitment}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.getHostNonceCommitment = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.AntiKleptoHostNonceCommitment} */ (
    jspb.Message.getWrapperField(this, antiklepto_pb.AntiKleptoHostNonceCommitment, 4));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.AntiKleptoHostNonceCommitment|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignMessageRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.setHostNonceCommitment = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignMessageRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.clearHostNonceCommitment = function() {
  return this.setHostNonceCommitment(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageRequest.prototype.hasHostNonceCommitment = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCSignMessageResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCSignMessageResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSignMessageResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    signature: msg.getSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignMessageResponse}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCSignMessageResponse;
  return proto.shiftcrypto.bitbox02.BTCSignMessageResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCSignMessageResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCSignMessageResponse}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCSignMessageResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCSignMessageResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCSignMessageResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes signature = 1;
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageResponse.prototype.getSignature = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes signature = 1;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageResponse.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCSignMessageResponse.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.shiftcrypto.bitbox02.BTCSignMessageResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCSignMessageResponse.prototype.setSignature = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.shiftcrypto.bitbox02.BTCRequest.oneofGroups_ = [[1,2,3,4,5,6,7]];

/**
 * @enum {number}
 */
proto.shiftcrypto.bitbox02.BTCRequest.RequestCase = {
  REQUEST_NOT_SET: 0,
  IS_SCRIPT_CONFIG_REGISTERED: 1,
  REGISTER_SCRIPT_CONFIG: 2,
  PREVTX_INIT: 3,
  PREVTX_INPUT: 4,
  PREVTX_OUTPUT: 5,
  SIGN_MESSAGE: 6,
  ANTIKLEPTO_SIGNATURE: 7
};

/**
 * @return {proto.shiftcrypto.bitbox02.BTCRequest.RequestCase}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.getRequestCase = function() {
  return /** @type {proto.shiftcrypto.bitbox02.BTCRequest.RequestCase} */(jspb.Message.computeOneofCase(this, proto.shiftcrypto.bitbox02.BTCRequest.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    isScriptConfigRegistered: (f = msg.getIsScriptConfigRegistered()) && proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.toObject(includeInstance, f),
    registerScriptConfig: (f = msg.getRegisterScriptConfig()) && proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.toObject(includeInstance, f),
    prevtxInit: (f = msg.getPrevtxInit()) && proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.toObject(includeInstance, f),
    prevtxInput: (f = msg.getPrevtxInput()) && proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.toObject(includeInstance, f),
    prevtxOutput: (f = msg.getPrevtxOutput()) && proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.toObject(includeInstance, f),
    signMessage: (f = msg.getSignMessage()) && proto.shiftcrypto.bitbox02.BTCSignMessageRequest.toObject(includeInstance, f),
    antikleptoSignature: (f = msg.getAntikleptoSignature()) && antiklepto_pb.AntiKleptoSignatureRequest.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest}
 */
proto.shiftcrypto.bitbox02.BTCRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCRequest;
  return proto.shiftcrypto.bitbox02.BTCRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest}
 */
proto.shiftcrypto.bitbox02.BTCRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.deserializeBinaryFromReader);
      msg.setIsScriptConfigRegistered(value);
      break;
    case 2:
      var value = new proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.deserializeBinaryFromReader);
      msg.setRegisterScriptConfig(value);
      break;
    case 3:
      var value = new proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.deserializeBinaryFromReader);
      msg.setPrevtxInit(value);
      break;
    case 4:
      var value = new proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.deserializeBinaryFromReader);
      msg.setPrevtxInput(value);
      break;
    case 5:
      var value = new proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.deserializeBinaryFromReader);
      msg.setPrevtxOutput(value);
      break;
    case 6:
      var value = new proto.shiftcrypto.bitbox02.BTCSignMessageRequest;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCSignMessageRequest.deserializeBinaryFromReader);
      msg.setSignMessage(value);
      break;
    case 7:
      var value = new antiklepto_pb.AntiKleptoSignatureRequest;
      reader.readMessage(value,antiklepto_pb.AntiKleptoSignatureRequest.deserializeBinaryFromReader);
      msg.setAntikleptoSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIsScriptConfigRegistered();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.serializeBinaryToWriter
    );
  }
  f = message.getRegisterScriptConfig();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.serializeBinaryToWriter
    );
  }
  f = message.getPrevtxInit();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest.serializeBinaryToWriter
    );
  }
  f = message.getPrevtxInput();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest.serializeBinaryToWriter
    );
  }
  f = message.getPrevtxOutput();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest.serializeBinaryToWriter
    );
  }
  f = message.getSignMessage();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.shiftcrypto.bitbox02.BTCSignMessageRequest.serializeBinaryToWriter
    );
  }
  f = message.getAntikleptoSignature();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      antiklepto_pb.AntiKleptoSignatureRequest.serializeBinaryToWriter
    );
  }
};


/**
 * optional BTCIsScriptConfigRegisteredRequest is_script_config_registered = 1;
 * @return {?proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.getIsScriptConfigRegistered = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest, 1));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCRequest.prototype.setIsScriptConfigRegistered = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.shiftcrypto.bitbox02.BTCRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.clearIsScriptConfigRegistered = function() {
  return this.setIsScriptConfigRegistered(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.hasIsScriptConfigRegistered = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional BTCRegisterScriptConfigRequest register_script_config = 2;
 * @return {?proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.getRegisterScriptConfig = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest, 2));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCRequest.prototype.setRegisterScriptConfig = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.shiftcrypto.bitbox02.BTCRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.clearRegisterScriptConfig = function() {
  return this.setRegisterScriptConfig(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.hasRegisterScriptConfig = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional BTCPrevTxInitRequest prevtx_init = 3;
 * @return {?proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.getPrevtxInit = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest, 3));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCPrevTxInitRequest|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCRequest.prototype.setPrevtxInit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.shiftcrypto.bitbox02.BTCRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.clearPrevtxInit = function() {
  return this.setPrevtxInit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.hasPrevtxInit = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional BTCPrevTxInputRequest prevtx_input = 4;
 * @return {?proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.getPrevtxInput = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest, 4));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCPrevTxInputRequest|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCRequest.prototype.setPrevtxInput = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.shiftcrypto.bitbox02.BTCRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.clearPrevtxInput = function() {
  return this.setPrevtxInput(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.hasPrevtxInput = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional BTCPrevTxOutputRequest prevtx_output = 5;
 * @return {?proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.getPrevtxOutput = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest, 5));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCPrevTxOutputRequest|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCRequest.prototype.setPrevtxOutput = function(value) {
  return jspb.Message.setOneofWrapperField(this, 5, proto.shiftcrypto.bitbox02.BTCRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.clearPrevtxOutput = function() {
  return this.setPrevtxOutput(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.hasPrevtxOutput = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional BTCSignMessageRequest sign_message = 6;
 * @return {?proto.shiftcrypto.bitbox02.BTCSignMessageRequest}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.getSignMessage = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCSignMessageRequest} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCSignMessageRequest, 6));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCSignMessageRequest|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCRequest.prototype.setSignMessage = function(value) {
  return jspb.Message.setOneofWrapperField(this, 6, proto.shiftcrypto.bitbox02.BTCRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.clearSignMessage = function() {
  return this.setSignMessage(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.hasSignMessage = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional AntiKleptoSignatureRequest antiklepto_signature = 7;
 * @return {?proto.shiftcrypto.bitbox02.AntiKleptoSignatureRequest}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.getAntikleptoSignature = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.AntiKleptoSignatureRequest} */ (
    jspb.Message.getWrapperField(this, antiklepto_pb.AntiKleptoSignatureRequest, 7));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.AntiKleptoSignatureRequest|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
*/
proto.shiftcrypto.bitbox02.BTCRequest.prototype.setAntikleptoSignature = function(value) {
  return jspb.Message.setOneofWrapperField(this, 7, proto.shiftcrypto.bitbox02.BTCRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCRequest} returns this
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.clearAntikleptoSignature = function() {
  return this.setAntikleptoSignature(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCRequest.prototype.hasAntikleptoSignature = function() {
  return jspb.Message.getField(this, 7) != null;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.shiftcrypto.bitbox02.BTCResponse.oneofGroups_ = [[1,2,3,4,5]];

/**
 * @enum {number}
 */
proto.shiftcrypto.bitbox02.BTCResponse.ResponseCase = {
  RESPONSE_NOT_SET: 0,
  SUCCESS: 1,
  IS_SCRIPT_CONFIG_REGISTERED: 2,
  SIGN_NEXT: 3,
  SIGN_MESSAGE: 4,
  ANTIKLEPTO_SIGNER_COMMITMENT: 5
};

/**
 * @return {proto.shiftcrypto.bitbox02.BTCResponse.ResponseCase}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.getResponseCase = function() {
  return /** @type {proto.shiftcrypto.bitbox02.BTCResponse.ResponseCase} */(jspb.Message.computeOneofCase(this, proto.shiftcrypto.bitbox02.BTCResponse.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.shiftcrypto.bitbox02.BTCResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.shiftcrypto.bitbox02.BTCResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    success: (f = msg.getSuccess()) && proto.shiftcrypto.bitbox02.BTCSuccess.toObject(includeInstance, f),
    isScriptConfigRegistered: (f = msg.getIsScriptConfigRegistered()) && proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.toObject(includeInstance, f),
    signNext: (f = msg.getSignNext()) && proto.shiftcrypto.bitbox02.BTCSignNextResponse.toObject(includeInstance, f),
    signMessage: (f = msg.getSignMessage()) && proto.shiftcrypto.bitbox02.BTCSignMessageResponse.toObject(includeInstance, f),
    antikleptoSignerCommitment: (f = msg.getAntikleptoSignerCommitment()) && antiklepto_pb.AntiKleptoSignerCommitment.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.shiftcrypto.bitbox02.BTCResponse}
 */
proto.shiftcrypto.bitbox02.BTCResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.shiftcrypto.bitbox02.BTCResponse;
  return proto.shiftcrypto.bitbox02.BTCResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.shiftcrypto.bitbox02.BTCResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.shiftcrypto.bitbox02.BTCResponse}
 */
proto.shiftcrypto.bitbox02.BTCResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.shiftcrypto.bitbox02.BTCSuccess;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCSuccess.deserializeBinaryFromReader);
      msg.setSuccess(value);
      break;
    case 2:
      var value = new proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.deserializeBinaryFromReader);
      msg.setIsScriptConfigRegistered(value);
      break;
    case 3:
      var value = new proto.shiftcrypto.bitbox02.BTCSignNextResponse;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCSignNextResponse.deserializeBinaryFromReader);
      msg.setSignNext(value);
      break;
    case 4:
      var value = new proto.shiftcrypto.bitbox02.BTCSignMessageResponse;
      reader.readMessage(value,proto.shiftcrypto.bitbox02.BTCSignMessageResponse.deserializeBinaryFromReader);
      msg.setSignMessage(value);
      break;
    case 5:
      var value = new antiklepto_pb.AntiKleptoSignerCommitment;
      reader.readMessage(value,antiklepto_pb.AntiKleptoSignerCommitment.deserializeBinaryFromReader);
      msg.setAntikleptoSignerCommitment(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.shiftcrypto.bitbox02.BTCResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.shiftcrypto.bitbox02.BTCResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.shiftcrypto.bitbox02.BTCResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSuccess();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.shiftcrypto.bitbox02.BTCSuccess.serializeBinaryToWriter
    );
  }
  f = message.getIsScriptConfigRegistered();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse.serializeBinaryToWriter
    );
  }
  f = message.getSignNext();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.shiftcrypto.bitbox02.BTCSignNextResponse.serializeBinaryToWriter
    );
  }
  f = message.getSignMessage();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.shiftcrypto.bitbox02.BTCSignMessageResponse.serializeBinaryToWriter
    );
  }
  f = message.getAntikleptoSignerCommitment();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      antiklepto_pb.AntiKleptoSignerCommitment.serializeBinaryToWriter
    );
  }
};


/**
 * optional BTCSuccess success = 1;
 * @return {?proto.shiftcrypto.bitbox02.BTCSuccess}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.getSuccess = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCSuccess} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCSuccess, 1));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCSuccess|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCResponse} returns this
*/
proto.shiftcrypto.bitbox02.BTCResponse.prototype.setSuccess = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.shiftcrypto.bitbox02.BTCResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.clearSuccess = function() {
  return this.setSuccess(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.hasSuccess = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional BTCIsScriptConfigRegisteredResponse is_script_config_registered = 2;
 * @return {?proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.getIsScriptConfigRegistered = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse, 2));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCResponse} returns this
*/
proto.shiftcrypto.bitbox02.BTCResponse.prototype.setIsScriptConfigRegistered = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.shiftcrypto.bitbox02.BTCResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.clearIsScriptConfigRegistered = function() {
  return this.setIsScriptConfigRegistered(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.hasIsScriptConfigRegistered = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional BTCSignNextResponse sign_next = 3;
 * @return {?proto.shiftcrypto.bitbox02.BTCSignNextResponse}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.getSignNext = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCSignNextResponse} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCSignNextResponse, 3));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCSignNextResponse|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCResponse} returns this
*/
proto.shiftcrypto.bitbox02.BTCResponse.prototype.setSignNext = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.shiftcrypto.bitbox02.BTCResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.clearSignNext = function() {
  return this.setSignNext(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.hasSignNext = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional BTCSignMessageResponse sign_message = 4;
 * @return {?proto.shiftcrypto.bitbox02.BTCSignMessageResponse}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.getSignMessage = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.BTCSignMessageResponse} */ (
    jspb.Message.getWrapperField(this, proto.shiftcrypto.bitbox02.BTCSignMessageResponse, 4));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.BTCSignMessageResponse|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCResponse} returns this
*/
proto.shiftcrypto.bitbox02.BTCResponse.prototype.setSignMessage = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.shiftcrypto.bitbox02.BTCResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.clearSignMessage = function() {
  return this.setSignMessage(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.hasSignMessage = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional AntiKleptoSignerCommitment antiklepto_signer_commitment = 5;
 * @return {?proto.shiftcrypto.bitbox02.AntiKleptoSignerCommitment}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.getAntikleptoSignerCommitment = function() {
  return /** @type{?proto.shiftcrypto.bitbox02.AntiKleptoSignerCommitment} */ (
    jspb.Message.getWrapperField(this, antiklepto_pb.AntiKleptoSignerCommitment, 5));
};


/**
 * @param {?proto.shiftcrypto.bitbox02.AntiKleptoSignerCommitment|undefined} value
 * @return {!proto.shiftcrypto.bitbox02.BTCResponse} returns this
*/
proto.shiftcrypto.bitbox02.BTCResponse.prototype.setAntikleptoSignerCommitment = function(value) {
  return jspb.Message.setOneofWrapperField(this, 5, proto.shiftcrypto.bitbox02.BTCResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.shiftcrypto.bitbox02.BTCResponse} returns this
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.clearAntikleptoSignerCommitment = function() {
  return this.setAntikleptoSignerCommitment(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.shiftcrypto.bitbox02.BTCResponse.prototype.hasAntikleptoSignerCommitment = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * @enum {number}
 */
proto.shiftcrypto.bitbox02.BTCCoin = {
  BTC: 0,
  TBTC: 1,
  LTC: 2,
  TLTC: 3
};

/**
 * @enum {number}
 */
proto.shiftcrypto.bitbox02.BTCOutputType = {
  UNKNOWN: 0,
  P2PKH: 1,
  P2SH: 2,
  P2WPKH: 3,
  P2WSH: 4
};

goog.object.extend(exports, proto.shiftcrypto.bitbox02);
